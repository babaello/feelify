<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Feelify – Songs for Your Mood</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;600&display=swap');
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0; 
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #1DB954, #191414);
      color: #eee;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      padding: 1rem 1.5rem;
      user-select: none;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }
    h1 {
      color: #fff;
      font-weight: 600;
      letter-spacing: 2px;
      text-align: center;
      margin-bottom: 1rem;
      user-select: text;
    }
    button, input, select {
      font-family: inherit;
      font-weight: 600;
      font-size: 1.1rem;
      padding: 0.6rem 1rem;
      margin: 0.4rem 0;
      border-radius: 30px;
      border: none;
      outline: none;
      transition: all 0.3s ease;
      width: 100%;
      max-width: 100%;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      cursor: pointer;
    }
    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
    button:hover:not(:disabled) {
      filter: brightness(1.2);
      box-shadow: 0 4px 15px rgba(29, 185, 84, 0.75);
    }
    input {
      border: 2px solid #1DB954;
      background: rgba(255, 255, 255, 0.1);
      color: #eee;
      padding-left: 1rem;
    }
    #loginBtn {
      background: #1DB954;
      color: #111;
      font-weight: 700;
      margin-bottom: 1rem;
    }
    #app {
      display: none;
    }
    #results {
      margin-top: 1rem;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      max-height: 400px;
      overflow-y: auto;
      padding: 0.5rem 1rem;
    }
    .track {
      display: flex;
      align-items: center;
      margin-bottom: 0.8rem;
      padding: 0.6rem;
      border-radius: 8px;
      background: rgba(255 255 255 / 0.05);
      transition: background 0.3s ease;
      user-select: none;
    }
    .track:hover {
      background: rgba(29,185,84,0.2);
    }
    .track img {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      margin-right: 1rem;
      flex-shrink: 0;
      box-shadow: 0 0 6px #1DB954;
    }
    .track-info {
      flex-grow: 1;
      overflow: hidden;
    }
    .track-info a {
      color: #1DB954;
      font-weight: 700;
      text-decoration: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: block;
      user-select: text;
    }
    .track-info small {
      display: block;
      color: #bbb;
      font-weight: 300;
      font-size: 0.85rem;
      margin-top: 0.15rem;
      user-select: text;
    }
    .actions {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      margin-left: 1rem;
      flex-shrink: 0;
    }
    .actions button {
      padding: 0.3rem 0.5rem;
      font-size: 1rem;
      border-radius: 50%;
      width: 34px;
      height: 34px;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      background: rgba(29,185,84,0.9);
      color: #111;
      font-weight: 700;
    }
    .actions button:hover {
      background: #1ed760;
      color: #000;
    }
    #message {
      margin-top: 0.6rem;
      font-weight: 500;
      text-align: center;
      min-height: 1.2rem;
      user-select: none;
    }
    #player {
      margin-top: 1rem;
      width: 100%;
      height: 80px;
      border-radius: 15px;
      background: rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #createPlaylistBtn {
      margin-top: 1rem;
      background: #191414;
      color: #1DB954;
      font-weight: 700;
      border: 2px solid #1DB954;
    }
    #shareLinks {
      margin-top: 1rem;
      text-align: center;
    }
    #shareLinks a {
      margin: 0 0.4rem;
      color: #1DB954;
      text-decoration: none;
      font-weight: 600;
    }
    #shareLinks a:hover {
      text-decoration: underline;
    }
    /* Scrollbar */
    #results::-webkit-scrollbar {
      width: 8px;
    }
    #results::-webkit-scrollbar-thumb {
      background: #1DB954;
      border-radius: 4px;
    }
  </style>
</head>
<body>

  <h1>Feelify</h1>
  <button id="loginBtn">Log in with Spotify</button>

  <div id="app">
    <input type="text" id="moodInput" placeholder="Enter your mood or vibe" autocomplete="off" />
    <button id="searchBtn">Find Songs</button>
    <button id="createPlaylistBtn" disabled>Create Playlist from Results</button>
    <div id="message"></div>
    <div id="results"></div>
    <div id="player"></div>
    <div id="shareLinks"></div>
  </div>

<script>
  const clientId = 'acb4336604304c339c55eb6db62513ca';
  const redirectUri = 'https://babaello.github.io/feelify/';
  const backendUrl = 'https://feelify-backend.onrender.com';

  const loginBtn = document.getElementById('loginBtn');
  const appDiv = document.getElementById('app');
  const searchBtn = document.getElementById('searchBtn');
  const createPlaylistBtn = document.getElementById('createPlaylistBtn');
  const moodInput = document.getElementById('moodInput');
  const resultsDiv = document.getElementById('results');
  const messageDiv = document.getElementById('message');
  const playerDiv = document.getElementById('player');
  const shareLinksDiv = document.getElementById('shareLinks');

  let accessToken = null;
  let currentTracks = [];
  let currentMood = null;
  let votes = {}; // trackId -> upvotes/downvotes count

  // Mood to audio features mapping for Spotify Recommendations API
  const moodFeaturesMap = {
    happy: { target_valence: 0.9, target_energy: 0.8, target_danceability: 0.75 },
    sad: { target_valence: 0.2, target_energy: 0.3, target_danceability: 0.25 },
    relaxed: { target_valence: 0.7, target_energy: 0.35, target_danceability: 0.4 },
    energetic: { target_valence: 0.8, target_energy: 0.9, target_danceability: 0.85 },
    calm: { target_valence: 0.6, target_energy: 0.2, target_danceability: 0.35 },
    angry: { target_valence: 0.3, target_energy: 0.9, target_danceability: 0.55 },
    chill: { target_valence: 0.75, target_energy: 0.35, target_danceability: 0.55 },
    romantic: { target_valence: 0.85, target_energy: 0.5, target_danceability: 0.6 },
    dreamy: { target_valence: 0.8, target_energy: 0.3, target_danceability: 0.5 },
    lonely: { target_valence: 0.25, target_energy: 0.2, target_danceability: 0.3 }
  };

  // Synonyms mapping to normalize user input
  const moodSynonyms = {
    glad: 'happy',
    joyful: 'happy',
    sorrowful: 'sad',
    depressed: 'sad',
    mellow: 'relaxed',
    peaceful: 'calm',
    furious: 'angry',
    upset: 'angry',
    loving: 'romantic',
    dreamy: 'dreamy',
    alone: 'lonely',
    lonely: 'lonely',
    chilled: 'chill',
    energetic: 'energetic',
    hype: 'energetic',
  };

  // Extract code from URL query params on load
  const params = new URLSearchParams(window.location.search);
  const code = params.get('code');

  if (code) {
    loginBtn.style.display = 'none';
    messageDiv.textContent = 'Logging in...';
    fetch(`${backendUrl}/exchange_token?code=${code}`)
      .then(res => res.json())
      .then(data => {
        if (data.access_token) {
          accessToken = data.access_token;
          messageDiv.textContent = 'Logged in! Enter your mood to find songs.';
          appDiv.style.display = 'block';
          history.replaceState(null, '', redirectUri);
        } else {
          messageDiv.textContent = 'Error getting access token.';
          loginBtn.style.display = 'block';
        }
      })
      .catch(() => {
        messageDiv.textContent = 'Failed to connect to backend.';
        loginBtn.style.display = 'block';
      });
  }

  loginBtn.onclick = () => {
    const scopes = [
      'user-read-private',
      'user-read-email',
      'playlist-modify-public',
      'playlist-modify-private',
      'streaming',
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
    ].join(' ');
    const authUrl =
      `https://accounts.spotify.com/authorize` +
      `?client_id=${clientId}` +
      `&response_type=code` +
      `&redirect_uri=${encodeURIComponent(redirectUri)}` +
      `&scope=${encodeURIComponent(scopes)}` +
      `&show_dialog=true`;
    window.location.href = authUrl;
  };

  searchBtn.onclick = () => {
    const moodRaw = moodInput.value.trim();
    if (!accessToken) return alert('Please log in first.');
    if (!moodRaw) return alert('Please enter a mood or vibe.');

    // Normalize mood input
    let mood = moodRaw.toLowerCase();
    if (moodSynonyms[mood]) mood = moodSynonyms[mood];

    currentMood = mood;
    createPlaylistBtn.disabled = true;
    resultsDiv.innerHTML = '';
    messageDiv.textContent = 'Searching...';
    shareLinksDiv.innerHTML = '';
    playerDiv.innerHTML = '';

    if (moodFeaturesMap[mood]) {
      searchByMoodFeatures(mood);
    } else {
      // fallback to simple search by name
      searchByName(moodRaw);
    }
  };

  // Search tracks using Spotify Recommendations API based on mood features
  async function searchByMoodFeatures(mood) {
    try {
      const features = moodFeaturesMap[mood];
      const params = new URLSearchParams({
        limit: 20,
        seed_genres: 'pop',
        target_valence: features.target_valence,
        target_energy: features.target_energy,
        target_danceability: features.target_danceability,
      });

      const res = await fetch(`https://api.spotify.com/v1/recommendations?${params.toString()}`, {
        headers: { Authorization: `Bearer ${accessToken}` }
      });

      if (!res.ok) throw new Error('Spotify recommendations fetch failed');

      const data = await res.json();
      currentTracks = data.tracks;

      if (currentTracks.length === 0) {
        messageDiv.textContent = 'No songs found for that mood.';
        return;
      }
      messageDiv.textContent = `Songs recommended for mood: "${mood}"`;
      votes = {};
      renderTracks(currentTracks);
      createPlaylistBtn.disabled = false;
      setupShareLinks(mood);

    } catch (error) {
      console.error(error);
      messageDiv.textContent = 'Failed to get recommendations.';
    }
  }

  // Fallback search by track name
  async function searchByName(query) {
    try {
      const res = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=20`, {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      if (!res.ok) throw new Error('Spotify search fetch failed');

      const data = await res.json();
      currentTracks = data.tracks.items;

      if (currentTracks.length === 0) {
        messageDiv.textContent = 'No songs found for that search.';
        return;
      }
      messageDiv.textContent = `Songs found for search: "${query}"`;
      votes = {};
      renderTracks(currentTracks);
      createPlaylistBtn.disabled = false;
      setupShareLinks(query);

    } catch (error) {
      console.error(error);
      messageDiv.textContent = 'Failed to search songs.';
    }
  }

  // Render tracks list in UI
  function renderTracks(tracks) {
    resultsDiv.innerHTML = '';
    tracks.forEach(track => {
      const trackEl = document.createElement('div');
      trackEl.className = 'track';

      // Album art
      const img = document.createElement('img');
      img.src = track.album.images[2]?.url || track.album.images[0]?.url || '';
      img.alt = track.name;
      trackEl.appendChild(img);

      // Track info container
      const info = document.createElement('div');
      info.className = 'track-info';

      // Track name (link to Spotify)
      const link = document.createElement('a');
      link.href = track.external_urls.spotify;
      link.target = '_blank';
      link.textContent = track.name;
      info.appendChild(link);

      // Artist(s)
      const artists = document.createElement('small');
      artists.textContent = track.artists.map(a => a.name).join(', ');
      info.appendChild(artists);

      trackEl.appendChild(info);

      // Actions (play, upvote, downvote)
      const actions = document.createElement('div');
      actions.className = 'actions';

      // Play button
      const playBtn = document.createElement('button');
      playBtn.title = 'Play Preview';
      playBtn.innerHTML = '▶️';
      playBtn.onclick = () => playPreview(track);
      actions.appendChild(playBtn);

      // Upvote button
      const upvoteBtn = document.createElement('button');
      upvoteBtn.title = 'Upvote';
      upvoteBtn.textContent = '👍';
      upvoteBtn.onclick = () => voteTrack(track.id, +1);
      actions.appendChild(upvoteBtn);

      // Downvote button
      const downvoteBtn = document.createElement('button');
      downvoteBtn.title = 'Downvote';
      downvoteBtn.textContent = '👎';
      downvoteBtn.onclick = () => voteTrack(track.id, -1);
      actions.appendChild(downvoteBtn);

      trackEl.appendChild(actions);

      resultsDiv.appendChild(trackEl);
    });
  }

  // Playback audio preview
  let audio = null;
  function playPreview(track) {
    if (audio) {
      audio.pause();
      audio = null;
      playerDiv.innerHTML = '';
    }

    if (!track.preview_url) {
      messageDiv.textContent = 'No preview available for this track.';
      return;
    }

    audio = new Audio(track.preview_url);
    audio.play();
    messageDiv.textContent = `Playing preview: ${track.name} by ${track.artists.map(a => a.name).join(', ')}`;

    // Show player controls
    playerDiv.innerHTML = `
      <strong>Now Playing:</strong> ${track.name} — ${track.artists.map(a => a.name).join(', ')}<br />
      <button id="pauseBtn">⏸️ Pause</button> <button id="stopBtn">⏹️ Stop</button>
    `;

    document.getElementById('pauseBtn').onclick = () => {
      if (audio.paused) {
        audio.play();
        document.getElementById('pauseBtn').textContent = '⏸️ Pause';
      } else {
        audio.pause();
        document.getElementById('pauseBtn').textContent = '▶️ Play';
      }
    };

    document.getElementById('stopBtn').onclick = () => {
      audio.pause();
      audio.currentTime = 0;
      playerDiv.innerHTML = '';
      messageDiv.textContent = '';
      audio = null;
    };

    audio.onended = () => {
      playerDiv.innerHTML = '';
      messageDiv.textContent = '';
      audio = null;
    };
  }

  // Track voting logic
  function voteTrack(trackId, delta) {
    if (!votes[trackId]) votes[trackId] = 0;
    votes[trackId] += delta;
    messageDiv.textContent = `Votes for track updated: ${
    votes[trackId] += delta;
    // Clamp votes so they don't go below 0 (optional)
    if (votes[trackId] < 0) votes[trackId] = 0;

    messageDiv.textContent = `Votes updated: ${votes[trackId]} for this track.`;
  }

  // Create playlist from current tracks and votes
  createPlaylistBtn.onclick = async () => {
    if (!accessToken) return alert('Please log in first.');

    messageDiv.textContent = 'Creating playlist...';
    createPlaylistBtn.disabled = true;

    try {
      // Get current user profile to create playlist
      const profileRes = await fetch('https://api.spotify.com/v1/me', {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      if (!profileRes.ok) throw new Error('Failed to fetch user profile');
      const profile = await profileRes.json();

      // Sort tracks by votes descending (default to zero votes if none)
      const sortedTracks = currentTracks
        .map(track => ({ track, score: votes[track.id] || 0 }))
        .sort((a, b) => b.score - a.score)
        .map(t => t.track);

      // Create playlist with a name that includes mood and timestamp
      const playlistName = `Feelify: ${currentMood} Playlist ${new Date().toLocaleDateString()}`;
      const createPlaylistRes = await fetch(`https://api.spotify.com/v1/users/${profile.id}/playlists`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: playlistName,
          description: `Playlist generated by Feelify for mood "${currentMood}"`,
          public: false,
        }),
      });

      if (!createPlaylistRes.ok) throw new Error('Failed to create playlist');

      const playlistData = await createPlaylistRes.json();

      // Add tracks to playlist (Spotify URIs)
      const uris = sortedTracks.map(t => t.uri);

      // Spotify API limits to 100 tracks per add call; we have <= 20 so safe
      const addTracksRes = await fetch(`https://api.spotify.com/v1/playlists/${playlistData.id}/tracks`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ uris }),
      });

      if (!addTracksRes.ok) throw new Error('Failed to add tracks to playlist');

      messageDiv.textContent = `Playlist created! You can listen to it in your Spotify app.`;

      // Show share link to playlist
      shareLinksDiv.innerHTML = `
        <strong>Playlist link:</strong><br/>
        <a href="${playlistData.external_urls.spotify}" target="_blank">${playlistData.name}</a>
      `;

    } catch (err) {
      console.error(err);
      messageDiv.textContent = 'Error creating playlist: ' + err.message;
    } finally {
      createPlaylistBtn.disabled = false;
    }
  };

  // Setup share links for social platforms (simple share of current page + mood)
  function setupShareLinks(mood) {
    const url = new URL(window.location.href);
    url.searchParams.set('mood', mood);
    const shareUrl = url.toString();

    shareLinksDiv.innerHTML = `
      <strong>Share your mood and songs:</strong><br/>
      <a href="https://twitter.com/intent/tweet?text=Check%20out%20my%20mood-based%20playlist%20on%20Feelify!%20Mood:%20${encodeURIComponent(mood)}&url=${encodeURIComponent(shareUrl)}" target="_blank">Twitter</a> |
      <a href="https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}" target="_blank">Facebook</a> |
      <a href="https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(shareUrl)}" target="_blank">LinkedIn</a>
    `;
  }

  // Optional: On page load, if mood param exists, auto-search
  window.addEventListener('load', () => {
    const moodParam = params.get('mood');
    if (moodParam && accessToken) {
      moodInput.value = moodParam;
      searchBtn.click();
    }
  });
</script>

</body>
</html>
